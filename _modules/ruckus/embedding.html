
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ruckus.embedding &#8212; ruckus 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>ruckus 0.0.1 documentation</span></a></h1>
        <h2 class="heading"><span>ruckus.embedding</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content" role="main">
        
        
  <h1>Source code for ruckus.embedding</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">ruckus.utils</span> <span class="kn">import</span> <span class="n">_DecoyCenterer</span>
<span class="kn">from</span> <span class="nn">ruckus.base</span> <span class="kn">import</span> <span class="n">RKHS</span> <span class="k">as</span> <span class="n">_RKHS</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">KernelPCA</span> <span class="k">as</span> <span class="n">_KernelPCA</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">KernelCenterer</span> <span class="k">as</span> <span class="n">_KernelCenterer</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span> <span class="k">as</span> <span class="n">_KMeans</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="kn">import</span> <span class="n">pairwise_kernels</span> <span class="k">as</span> <span class="n">_pairwise_kernels</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.validation</span> <span class="kn">import</span> <span class="n">check_is_fitted</span> <span class="k">as</span> <span class="n">_check_is_fitted</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">_st</span>


<span class="c1"># SPECIFIC RKHS&#39;S</span>

<span class="c1">## EigenRKHS</span>
<div class="viewcode-block" id="EigenRKHS"><a class="viewcode-back" href="../../api/embedding/EigenRKHS.html#ruckus.embedding.EigenRKHS">[docs]</a><span class="k">class</span> <span class="nc">EigenRKHS</span><span class="p">(</span><span class="n">_KernelPCA</span><span class="p">,</span><span class="n">_RKHS</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ``EigenRKHS`` is a child class of :py:class:`sklearn.decomposition._kernel_pca.KernelPCA`, </span>
<span class="sd">    which adapts it to our :py:class:`RKHS` class formula, allowing interactivity with other</span>
<span class="sd">    RKHS&#39;s. We also add new options regarding centering and Nyström sampling for efficiency.</span>
<span class="sd">    Because of this dependency, our code and documentation inherits notably from that of ``KernelPCA``,</span>
<span class="sd">    particularly in methods where only minor revisions were made.</span>

<span class="sd">    ``EigenRKHS`` is initialized with a kernel :math:`k(x,y)`---which now defaults to a Gaussian RBF---and </span>
<span class="sd">    computes the eigenvector decomposition :math:`k(x,y) = \sum_a \lambda_a \phi_a(x)\phi_a(x)` </span>
<span class="sd">    to determine the</span>
<span class="sd">    feature mappings :math:`\phi(x)` into the Hilbert space :math:`\mathcal{H}`. Because computing the</span>
<span class="sd">    eigenvectors scales cubically with the number of samples, we have added options for Nyström sampling,</span>
<span class="sd">    which selects a smaller subset of the data to use for the eigenvector computation, and then uses those</span>
<span class="sd">    eigenvectors to transform the remaining data [1].</span>

<span class="sd">    1. `Williams, C., Seeger, M. &quot;Using the Nyström Method to Speed Up Kernel Machines.&quot; Advances in Neural Information Processing Systems 13 (NIPS 2000) &lt;https://papers.nips.cc/paper/2000/hash/19de10adbaa1b2ee13f77f679fa1483a-Abstract.html/&gt;`_</span>
<span class="sd">    </span>
<span class="sd">    ==========</span>
<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    :param use_kernel: Default = ``&quot;rbf&quot;``.</span>
<span class="sd">        See :py:class:`sklearn.decomposition._kernel_pca.KernelPCA` for kernel options.</span>
<span class="sd">    :type use_kernel: ``str`` or ``callable``</span>
<span class="sd">    :param gamma: Default = ``None``. Kernel coefficient for rbf, poly and sigmoid kernels. Ignored by other kernels. If ``gamma`` is ``None``, then it is set to ``1/n_features``.</span>
<span class="sd">    :type gamma: ``float``</span>
<span class="sd">    :param degree: Default = 3. Degree for poly kernels. Ignored by other kernels.</span>
<span class="sd">    :type degree: ``int``</span>
<span class="sd">    :param coef0: Default = 1. Independent term in poly and sigmoid kernels. Ignored by other kernels.</span>
<span class="sd">    :type coef0: ``float``</span>
<span class="sd">    :param kernel_params: Default = ``None``. Parameters (keyword arguments) and values for kernel passed as callable object. Ignored by other kernels.</span>
<span class="sd">    :type kernel_params: ``dict``</span>
<span class="sd">    :param n_jobs: Default = ``None``. Number of parallel jobs to run. See :py:class:`sklearn.decomposition._kernel_pca.KernelPCA` for details.</span>
<span class="sd">    :type n_jobs: ``int``</span>
<span class="sd">    :param n_nystrom_samples: Default = ``1.0``. The number of samples to draw from ``X`` to compute the SVD. If ``int``, then draw ``n_nystrom_samples`` samples. If float, then draw ``n_nystrom_samples * X.shape[0]`` samples.</span>
<span class="sd">    :type n_nystrom_samples: ``int`` or ``float``</span>
<span class="sd">    :param sample_method: Default = ``&quot;random&quot;``. How to draw the Nyström samples. If ``&quot;random&quot;``, then subsample randomly with replacement. If ``&quot;kmeans&quot;``, then find the ``n_nystrom_samples`` optimal means.</span>
<span class="sd">    :type sample_method: ``str``</span>
<span class="sd">    :param sample_iter: Default = 300. If ``sample_method = &quot;kmeans&quot;``, the number of times to iterate the algorithm.</span>
<span class="sd">    :param n_components: Default = ``None``. Number of components. If None, all non-zero components are kept.</span>
<span class="sd">    :type n_components: ``int``</span>
<span class="sd">    :param centered: Default = ``False``. Whether to center the kernel before computing the SVD. This must be ``False`` for embeddings of distributions to be valid.</span>
<span class="sd">    :param eigen_solver: Default = ``&quot;auto&quot;``. Solver to use for eigenvector computation. See :py:class:`sklearn.decomposition._kernel_pca.KernelPCA` for details.</span>
<span class="sd">    :type eigen_solver: {``&quot;auto&quot;``, ``&quot;dense&quot;``, ``&quot;arpack&quot;``, ``&quot;randomized&quot;``}</span>
<span class="sd">    :param tol: Default = 0. Convergence tolerance for arpack. If 0, optimal value will be chosen by arpack.</span>
<span class="sd">    :type tol: ``float``</span>
<span class="sd">    :param max_iter: Default = ``None``. Maximum number of iterations for arpack. If None, optimal value will be chosen by arpack.</span>
<span class="sd">    :type max_iter: ``int``</span>
<span class="sd">    :param iterated_power: Default = ``&quot;auto&quot;``. Number of iterations for the power method computed by ``svd_solver == &quot;randomized&quot;``. When ``&quot;auto&quot;``, it is set to 7 when ``n_components &lt; 0.1 * min(X.shape)``, other it is set to 4.</span>
<span class="sd">    :type iterated_power: ``int &gt;= 0`` or ``&quot;auto&quot;``</span>
<span class="sd">    :param remove_zero_eig: Default = ``False``.</span>
<span class="sd">        If True, then all components with zero eigenvalues are removed, so that the number of components in the output may be &lt; n_components (and sometimes even zero due to numerical instability). When n_components is None, this parameter is ignored and components with zero eigenvalues are removed regardless.</span>
<span class="sd">    :type remove_zero_eig: ``bool``</span>
<span class="sd">    :param random_state: Used when eigen_solver == &quot;arpack&quot; or &quot;randomized&quot;. :py:class:`sklearn.decomposition._kernel_pca.KernelPCA` for more details.</span>
<span class="sd">    :type random_state: ``int``</span>
<span class="sd">    :param take: Default = ``None``.</span>
<span class="sd">        Specifies which values to take from the datapoint for transformation.</span>
<span class="sd">        If ``None``, the entire datapoint will be taken in its original shape.</span>
<span class="sd">        If ``bool`` array, acts as a mask setting values marked ``False`` to ``0`` and leaving values marked True unchanged.</span>
<span class="sd">        If ``int`` array, the integers specify the indices (along the first feature dimension) which are to be taken, in the order/shape of the desired input.</span>
<span class="sd">        If ``tuple`` of ``int`` arrays, allows for drawing indices across multiple dimensions, similar to passing a ``tuple`` to a ``numpy`` array.</span>
<span class="sd">    :type take: :py:class:`numpy.ndarray` of ``dtype int`` or ``bool``, or ``tuple`` of :py:class:`numpy.ndarray` instances of type ``int``, or ``None``</span>
<span class="sd">    :param filter: Default = ``None``.</span>
<span class="sd">        Specifies a linear preprocessing of the data. Applied after take.</span>
<span class="sd">        If ``None``, no changes are made to the input data.</span>
<span class="sd">        If the same shape as the input datapoints, ``filter`` and the datapoint are multiplied elementwise. </span>
<span class="sd">        If ``filter`` has a larger dimension than the datapoint, then its first dimensions will be contracted with the datapoint via :py:func:`numpy.tensordot`. The final shape is determined by the remaining dimensions of filter.</span>
<span class="sd">    :type filter: :py:class:`numpy.ndarray` of ``dtype float`` or ``None``</span>
<span class="sd">    :param copy_X: Default = ``True``.</span>
<span class="sd">        If ``True``, input ``X`` is copied and stored by the model in the ``X_fit_`` attribute. If no further changes will be done to ``X``, setting ``copy_X=False`` saves memory by storing a reference.</span>
<span class="sd">    :type copy_X: ``bool``</span>

<span class="sd">    ==========</span>
<span class="sd">    Attributes</span>
<span class="sd">    ==========</span>

<span class="sd">    :param eigenvalues\_: Eigenvalues of the centered kernel matrix in decreasing order. If ``n_components`` and ``remove_zero_eig`` are not set, then all values are stored.</span>
<span class="sd">    :type eigenvalues\_: :py:class:`numpy.ndarray` of shape ``(n_components,)``</span>
<span class="sd">    :param eigenvectors\_: Eigenvectors of the kernel matrix. If ``n_components`` and ``remove_zero_eig`` are not set, then all components are stored.</span>
<span class="sd">    :type eigenvectors\_: :py:class:`numpy.ndarray` of shape ``(n_samples,n_components)``</span>
<span class="sd">    :param shape_in\_: The required shape of the input datapoints, aka the shape of the domain space :math:`X`.</span>
<span class="sd">    :type shape_in\_: ``tuple``</span>
<span class="sd">    :param shape_out\_: The final shape of the transformed datapoints, aka the shape of the Hilbert space :math:`H`.</span>
<span class="sd">    :type shape_out\_: ``tuple``</span>
<span class="sd">    :param X_fit\_: The data which was used to fit the model.</span>
<span class="sd">    :type X_fit\_: :py:class:`numpy.ndarray` of shape ``(n_samples,)+self.shape_in_``</span>
<span class="sd">    :param X_nys\_: The nystrom subsamples of the data used to fit the model.</span>
<span class="sd">    :type X_nys\_: :py:class:`numpy.ndarray` of shape ``(n_nystrom_samples,n_features_in_)``</span>
<span class="sd">    :param n_features_in\_: The size of the features after preprocessing.</span>
<span class="sd">    :type n_features_in\_: ``int``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">use_kernel</span><span class="o">=</span><span class="s2">&quot;rbf&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="c1"># Data/Kernel options</span>
        <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">coef0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">kernel_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="c1"># Nyström options</span>
        <span class="n">n_nystrom_samples</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">sample_method</span> <span class="o">=</span> <span class="s1">&#39;random&#39;</span><span class="p">,</span>
        <span class="n">sample_iter</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
        <span class="c1"># SVD options</span>
        <span class="n">n_components</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">centered</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">eigen_solver</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">max_iter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">iterated_power</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">remove_zero_eig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="c1"># Misc.</span>
        <span class="n">take</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy_X</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_kernel</span> <span class="o">=</span> <span class="n">use_kernel</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="n">degree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coef0</span> <span class="o">=</span> <span class="n">coef0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_params</span> <span class="o">=</span> <span class="n">kernel_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_nystrom_samples</span> <span class="o">=</span> <span class="n">n_nystrom_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_iter</span> <span class="o">=</span> <span class="n">sample_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_method</span> <span class="o">=</span> <span class="n">sample_method</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="n">n_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centered</span> <span class="o">=</span> <span class="n">centered</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eigen_solver</span> <span class="o">=</span> <span class="n">eigen_solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterated_power</span> <span class="o">=</span> <span class="n">iterated_power</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_zero_eig</span> <span class="o">=</span> <span class="n">remove_zero_eig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit_inverse_transform</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">take</span> <span class="o">=</span> <span class="n">take</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">filter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span> <span class="o">=</span> <span class="n">copy_X</span>

    <span class="k">def</span> <span class="nf">_get_kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Only difference with :py:func:`sklearn.decomposition._kernel_pca.KernelPCA._get_kernel` is that the ``metric`` is ``self.use_kernel`` and not ``self.kernel``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">use_kernel</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_params</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="s2">&quot;degree&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span> <span class="s2">&quot;coef0&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">coef0</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">_pairwise_kernels</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_kernel</span><span class="p">,</span> <span class="n">filter_params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span>
        <span class="p">)</span>

<div class="viewcode-block" id="EigenRKHS.kernel"><a class="viewcode-back" href="../../api/embedding/EigenRKHS.html#ruckus.embedding.EigenRKHS.kernel">[docs]</a>    <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies ``self.take`` and ``self.filter`` to data, then</span>
<span class="sd">        calls :py:func:`_get_kernel` for kernel evaluation.</span>

<span class="sd">        :param X: Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the number of features. Must be consistent with preprocessing instructions in ``self.take`` and ``self.factors``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :param Y: Default = ``None``.</span>
<span class="sd">            Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. Must be consistent with preprocessing instructions in ``self.take`` and ``self.factors``. If ``None``, ``X`` is used.</span>
<span class="sd">        :type Y: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :returns: The matrix ``K[i,j] = k(X[i],Y[j])`` </span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples_1,n_samples_2)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">,</span><span class="n">allow_nd</span><span class="o">=</span><span class="kc">True</span><span class="p">,)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_filter</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">_np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">,</span><span class="n">allow_nd</span><span class="o">=</span><span class="kc">True</span><span class="p">,)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_filter</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">_np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_kernel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span></div>
    
    <span class="k">def</span> <span class="nf">_get_nys_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes Nyström subsample of data: random samples with replacement if ``self.sample_method == &quot;random&quot;`` and optimal means if ``self.sample_method == &quot;kmeans&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_nystrom_samples</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
            <span class="n">n_nystrom_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nystrom_samples</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nystrom_samples</span><span class="o">&lt;=</span><span class="mf">1.0</span><span class="p">:</span>
            <span class="n">n_nystrom_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_nystrom_samples</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n_nystrom_samples must be either an integer or between 0 and 1.&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_nystrom_samples</span><span class="p">])</span>
            <span class="n">X_samples</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_method</span> <span class="o">==</span> <span class="s1">&#39;kmeans&#39;</span><span class="p">:</span>
            <span class="n">kmeans</span> <span class="o">=</span> <span class="n">_KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_nystrom_samples</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_iter</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">X_samples</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span>

        <span class="k">return</span> <span class="n">X_samples</span>

<div class="viewcode-block" id="EigenRKHS.fit"><a class="viewcode-back" href="../../api/embedding/EigenRKHS.html#ruckus.embedding.EigenRKHS.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model from data in ``X``. This method filters the data, determines whether it is to be centered, and takes the specified Nyström subsamples. </span>
<span class="sd">        After this, :py:func:`sklearn.decomposition._kernel_pca.KernelPCA._fit_transform` is invoked.</span>

<span class="sd">        :param X: Training vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. Must be consistent with preprocessing instructions in ``self.take`` and ``self.filter``. Final filtered data will be flattened on the feature axes.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``</span>

<span class="sd">        :param y: Not used, present for API consistency by convention.</span>
<span class="sd">        :type y: Ignored            </span>

<span class="sd">        :returns: The instance itself</span>
<span class="sd">        :rtype: :py:class:`RKHS`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">,</span><span class="n">allow_nd</span><span class="o">=</span><span class="kc">True</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">_np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_features_in_</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">centered</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_centerer</span> <span class="o">=</span> <span class="n">_KernelCenterer</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_centerer</span> <span class="o">=</span> <span class="n">_DecoyCenterer</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">X_nys_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_nys_samples</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_kernel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_nys_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_transform</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_out_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues_</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="EigenRKHS.transform"><a class="viewcode-back" href="../../api/embedding/EigenRKHS.html#ruckus.embedding.EigenRKHS.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform ``X``. This differs from :py:func:`sklearn.decomposition._kernel_pca.KernelPCA.transform` in the data preprocessing.</span>

<span class="sd">        :param X: Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :returns: The transformed data</span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples,)+self.shape_out_``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">,</span><span class="n">allow_nd</span><span class="o">=</span><span class="kc">True</span><span class="p">,)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_filter</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">_np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="c1">#return super().transform(X)</span>
        <span class="c1"># Compute centered gram matrix between X and training data X_fit_</span>
        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centerer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_kernel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_nys_</span><span class="p">))</span>

        <span class="c1"># scale eigenvectors (properly account for null-space for dot product)</span>
        <span class="n">non_zeros</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues_</span><span class="p">)</span>
        <span class="n">scaled_alphas</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors_</span><span class="p">)</span>
        <span class="n">scaled_alphas</span><span class="p">[:,</span> <span class="n">non_zeros</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors_</span><span class="p">[:,</span> <span class="n">non_zeros</span><span class="p">]</span> <span class="o">/</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues_</span><span class="p">[</span><span class="n">non_zeros</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Project with a scalar product between K and the scaled eigenvectors</span>
        <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">scaled_alphas</span><span class="p">)</span></div>

<div class="viewcode-block" id="EigenRKHS.fit_transform"><a class="viewcode-back" href="../../api/embedding/EigenRKHS.html#ruckus.embedding.EigenRKHS.fit_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model from data in ``X`` and transform ``X``.</span>

<span class="sd">        :param X: Training vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. Must be consistent with preprocessing instructions in ``self.take`` and ``self.filter``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``        </span>

<span class="sd">        :returns: The transformed data</span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples,)+self.shape_out_``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">X_transformed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">X_transformed</span></div></div>

<span class="c1">## RandomFourier</span>
<div class="viewcode-block" id="RandomFourierRBF"><a class="viewcode-back" href="../../api/embedding/RandomFourierRBF.html#ruckus.embedding.RandomFourierRBF">[docs]</a><span class="k">class</span> <span class="nc">RandomFourierRBF</span><span class="p">(</span><span class="n">_RKHS</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ``RandomFourierRBF`` generates an embedding map :math:`\phi:X\rightarrow H` by constructing random Fourier</span>
<span class="sd">    phase signals; that is,</span>

<span class="sd">    .. math::</span>

<span class="sd">        \phi(x) = \frac{1}{\sqrt{K}}\begin{bmatrix}</span>
<span class="sd">            e^{i x\cdot w_1} \\</span>
<span class="sd">            \vdots \\</span>
<span class="sd">            e^{i x\cdot w_K}</span>
<span class="sd">        \end{bmatrix}</span>

<span class="sd">    where :math:`K` is the specified ``n_components`` and :math:`(w_1,\dots,w_K)` is drawn from a multivariate</span>
<span class="sd">    normal with covariance matrix :math:`\mathrm{diag}(\gamma,\dots,\gamma)`. The result that the kernel</span>
<span class="sd">    :math:`k(x,y) = \left&lt;\phi(x),\phi(y)\right&gt;` is approximately a Gaussian RBF with scale parameter :math:`\gamma` [1].</span>

<span class="sd">    Rather than drawing a truly random set of phase vectors (which converges :math:`O(n^{-1/2})`)</span>
<span class="sd">    we use quasi-Monte Carlo sampling via :py:func:`scipy.stats.qmc.QMCEngine`, which converges :math:`O((\log n)^d n^{-1})`</span>
<span class="sd">    where :math:`d` corresponds to the number of features in :math:`X`.</span>

<span class="sd">    1. `Rahimi, A., Recht, B. &quot;Random Features for Large-Scale Kernel Machines.&quot; Advances in Neural Information Processing Systems 20 (NIPS 2007) &lt;https://papers.nips.cc/paper/2007/hash/013a006f03dbc5392effeb8f18fda755-Abstract.html/&gt;`_</span>
<span class="sd">    </span>
<span class="sd">    ==========</span>
<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    </span>
<span class="sd">    :param n_components: Default = 100. The number of random Fourier features to generate.</span>
<span class="sd">    :type n_components: ``int``</span>
<span class="sd">    :param gamma: Default = ``None``. Specifies the scale parameter of the Gaussian kernel to be approximated. If ``None``, set to ``1/n_features``.</span>
<span class="sd">    :type gamma: ``float``</span>
<span class="sd">    :param complex: Default = ``False``. If ``False``, the output vector has shape ``(n_samples,2*n_components)``, where real and imaginary parts are written in pairs.</span>
<span class="sd">    :type complex: ``bool``</span>
<span class="sd">    :param engine: Default = ``None``. The sampler class to use. If ``None``, set to :py:func:`scipy.stats.qmc.Sobol`.</span>
<span class="sd">    :type engine: child class of :py:func:`scipy.stats.qmc.QMCEngine`</span>
<span class="sd">    :param engine_params: Default = ``None``. Initialization parameters to use for ``engine``.</span>
<span class="sd">    :type engine_params: ``dict``</span>
<span class="sd">    :param take: Default = ``None``.</span>
<span class="sd">        Specifies which values to take from the datapoint for transformation.</span>
<span class="sd">        If ``None``, the entire datapoint will be taken in its original shape.</span>
<span class="sd">        If ``bool`` array, acts as a mask setting values marked ``False`` to ``0`` and leaving values marked True unchanged.</span>
<span class="sd">        If ``int`` array, the integers specify the indices (along the first feature dimension) which are to be taken, in the order/shape of the desired input.</span>
<span class="sd">        If ``tuple`` of ``int`` arrays, allows for drawing indices across multiple dimensions, similar to passing a ``tuple`` to a ``numpy`` array.</span>
<span class="sd">    :type take: :py:class:`numpy.ndarray` of ``dtype int`` or ``bool``, or ``tuple`` of :py:class:`numpy.ndarray` instances of type ``int``, or ``None``</span>
<span class="sd">    :param filter: Default = ``None``.</span>
<span class="sd">        Specifies a linear preprocessing of the data. Applied after take.</span>
<span class="sd">        If ``None``, no changes are made to the input data.</span>
<span class="sd">        If the same shape as the input datapoints, ``filter`` and the datapoint are multiplied elementwise. </span>
<span class="sd">        If ``filter`` has a larger dimension than the datapoint, then its first dimensions will be contracted with the datapoint via :py:func:`numpy.tensordot`. The final shape is determined by the remaining dimensions of filter.</span>
<span class="sd">    :type filter: :py:class:`numpy.ndarray` of ``dtype float`` or ``None``</span>
<span class="sd">    :param copy_X: Default = ``True``.</span>
<span class="sd">        If ``True``, input ``X`` is copied and stored by the model in the ``X_fit_`` attribute. If no further changes will be done to ``X``, setting ``copy_X=False`` saves memory by storing a reference.</span>
<span class="sd">    :type copy_X: ``bool``</span>

<span class="sd">    ==========</span>
<span class="sd">    Attributes</span>
<span class="sd">    ==========</span>

<span class="sd">    :param ws\_: Randomly-selected phase coefficients used to generate Fourier features.</span>
<span class="sd">    :type ws\_: :py:class:`numpy.ndarray` of shape ``(n_components,n_features)``</span>
<span class="sd">    :param shape_in\_: The required shape of the input datapoints, aka the shape of the domain space :math:`X`.</span>
<span class="sd">    :type shape_in\_: ``tuple``</span>
<span class="sd">    :param shape_out\_: The final shape of the transformed datapoints, aka the shape of the Hilbert space :math:`H`.</span>
<span class="sd">    :type shape_out\_: ``tuple``</span>
<span class="sd">    :param X_fit\_: The data which was used to fit the model.</span>
<span class="sd">    :type X_fit\_: :py:class:`numpy.ndarray` of shape ``(n_samples,)+self.shape_in_``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">n_components</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">complex</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">engine</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">engine_params</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">take</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy_X</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="n">n_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complex</span> <span class="o">=</span> <span class="nb">complex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="n">engine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">engine_params</span> <span class="o">=</span> <span class="n">engine_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">take</span> <span class="o">=</span> <span class="n">take</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">filter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span> <span class="o">=</span> <span class="n">copy_X</span>
    
<div class="viewcode-block" id="RandomFourierRBF.fit"><a class="viewcode-back" href="../../api/embedding/RandomFourierRBF.html#ruckus.embedding.RandomFourierRBF.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model from data in ``X``.</span>

<span class="sd">        :param X: Training vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. Must be consistent with preprocessing instructions in ``self.take`` and ``self.filter``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``</span>

<span class="sd">        :param y: Not used, present for API consistency by convention.</span>
<span class="sd">        :type y: Ignored            </span>

<span class="sd">        :returns: The instance itself</span>
<span class="sd">        :rtype: :py:class:`RKHS`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">,</span><span class="n">allow_nd</span><span class="o">=</span><span class="kc">True</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span><span class="p">)</span>
        <span class="n">n_features_in</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">n_features_in</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n_features_in</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;d&#39;</span><span class="p">:</span><span class="n">d</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine_params</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">engine</span> <span class="o">=</span> <span class="n">_st</span><span class="o">.</span><span class="n">qmc</span><span class="o">.</span><span class="n">Sobol</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">engine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="n">var</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">var</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>
        <span class="n">sampler</span> <span class="o">=</span> <span class="n">_st</span><span class="o">.</span><span class="n">qmc</span><span class="o">.</span><span class="n">MultivariateNormalQMC</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">d</span><span class="p">]),</span><span class="n">cov</span><span class="o">=</span><span class="n">cov</span><span class="p">,</span><span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ws_</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">)[:,:</span><span class="n">n_features_in</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,)</span><span class="o">+</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">complex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape_out_</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape_out_</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="RandomFourierRBF.transform"><a class="viewcode-back" href="../../api/embedding/RandomFourierRBF.html#ruckus.embedding.RandomFourierRBF.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform ``X``. </span>

<span class="sd">        :param X: Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :returns: The transformed data</span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples,)+self.shape_out_``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">,</span><span class="n">allow_nd</span><span class="o">=</span><span class="kc">True</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_in_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Shape of X is </span><span class="si">%s</span><span class="s1"> but must be equal to </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_in_</span><span class="p">)))</span>

        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_filter</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="n">featuremap</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ws_</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ws_</span><span class="o">.</span><span class="n">shape</span><span class="p">)))]</span><span class="o">*</span><span class="mi">2</span>
            <span class="p">)</span>
        <span class="p">)</span><span class="o">/</span><span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">complex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">featuremap</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">featuremap_real</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">featuremap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">featuremap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">featuremap_real</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">featuremap</span><span class="p">)</span>
            <span class="n">featuremap_real</span><span class="p">[:,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">featuremap</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">featuremap_real</span></div></div>
        
<span class="c1">## OneHot</span>
<div class="viewcode-block" id="OneHotRKHS"><a class="viewcode-back" href="../../api/embedding/OneHotRKHS.html#ruckus.embedding.OneHotRKHS">[docs]</a><span class="k">class</span> <span class="nc">OneHotRKHS</span><span class="p">(</span><span class="n">_RKHS</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ``OneHotRKHS`` is for processing categorical data.</span>
<span class="sd">    If :math:`X` is a discrete set, this generates an embedding map :math:`\phi:X\rightarrow H` </span>
<span class="sd">    into a Hilbert space :math:`H` whose dimension is the cardinality of :math:`X`, such that</span>
<span class="sd">    :math:`\phi(x)` maps the element :math:`x` to a one-hot vector with the 1-valued component </span>
<span class="sd">    in the dimension which uniquely corresponds to :math:`x`.</span>

<span class="sd">    This is particularly advantageous when working with kernel embeddings of distributions, as</span>
<span class="sd">    the embedded distribution vector is itself a probability vector (positive components and sums to 1).</span>
<span class="sd">    </span>
<span class="sd">    ==========</span>
<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    :param take: Default = ``None``.</span>
<span class="sd">        Specifies which values to take from the datapoint for transformation.</span>
<span class="sd">        If ``None``, the entire datapoint will be taken in its original shape.</span>
<span class="sd">        If ``bool`` array, acts as a mask setting values marked ``False`` to ``0`` and leaving values marked True unchanged.</span>
<span class="sd">        If ``int`` array, the integers specify the indices (along the first feature dimension) which are to be taken, in the order/shape of the desired input.</span>
<span class="sd">        If ``tuple`` of ``int`` arrays, allows for drawing indices across multiple dimensions, similar to passing a ``tuple`` to a ``numpy`` array.</span>
<span class="sd">    :type take: :py:class:`numpy.ndarray` of ``dtype int`` or ``bool``, or ``tuple`` of :py:class:`numpy.ndarray` instances of type ``int``, or ``None``</span>
<span class="sd">    :param copy_X: Default = ``True``.</span>
<span class="sd">        If ``True``, input ``X`` is copied and stored by the model in the ``X_fit_`` attribute. If no further changes will be done to ``X``, setting ``copy_X=False`` saves memory by storing a reference.</span>
<span class="sd">    :type copy_X: ``bool``</span>

<span class="sd">    ==========</span>
<span class="sd">    Attributes</span>
<span class="sd">    ==========</span>

<span class="sd">    :param alphabet\_: The unique elements from ``self.X_fit_``.</span>
<span class="sd">    :type alphabet\_: :py:class:`numpy.ndarray` of ``objects``</span>
<span class="sd">    :param shape_in\_: The required shape of the input datapoints, aka the shape of the domain space :math:`X`.</span>
<span class="sd">    :type shape_in\_: ``tuple``</span>
<span class="sd">    :param shape_out\_: The final shape of the transformed datapoints, aka the shape of the Hilbert space :math:`H`.</span>
<span class="sd">    :type shape_out\_: ``tuple``</span>
<span class="sd">    :param X_fit\_: The data which was used to fit the model.</span>
<span class="sd">    :type X_fit\_: :py:class:`numpy.ndarray` of shape ``(n_samples,)+self.shape_in_``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">take</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy_X</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="o">=</span><span class="n">take</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span> <span class="o">=</span> <span class="n">copy_X</span>

<div class="viewcode-block" id="OneHotRKHS.fit"><a class="viewcode-back" href="../../api/embedding/OneHotRKHS.html#ruckus.embedding.OneHotRKHS.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model from data in ``X``.</span>

<span class="sd">        :param X: Training vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. Must be consistent with preprocessing instructions in ``self.take``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``</span>

<span class="sd">        :param y: Not used, present for API consistency by convention.</span>
<span class="sd">        :type y: Ignored            </span>

<span class="sd">        :returns: The instance itself</span>
<span class="sd">        :rtype: :py:class:`RKHS`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_take</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alphabet_</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_in_</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_out_</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alphabet_</span><span class="p">),)</span>
        <span class="k">return</span> <span class="bp">self</span></div>
    
<div class="viewcode-block" id="OneHotRKHS.transform"><a class="viewcode-back" href="../../api/embedding/OneHotRKHS.html#ruckus.embedding.OneHotRKHS.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform ``X``. </span>

<span class="sd">        :param X: Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :returns: The transformed data</span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples,)+self.shape_out_``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_take</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">alphabet_</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_out_</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="OneHotRKHS.kernel"><a class="viewcode-back" href="../../api/embedding/OneHotRKHS.html#ruckus.embedding.OneHotRKHS.kernel">[docs]</a>    <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies ``self.take`` and ``self.filter`` to data, then</span>
<span class="sd">        calls :py:func:`_get_kernel` for kernel evaluation.</span>

<span class="sd">        :param X: Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the number of features. Must be consistent with preprocessing instructions in ``self.take``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :param Y: Default = ``None``.</span>
<span class="sd">            Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. Must be consistent with preprocessing instructions in ``self.take``. If ``None``, ``X`` is used.</span>
<span class="sd">        :type Y: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :returns: The matrix ``K[i,j] = k(X[i],Y[j])`` </span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples_1,n_samples_2)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span>
        <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="n">Y</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="o">==</span> <span class="n">Y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">+</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div></div>
</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Samuel Loomis.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>