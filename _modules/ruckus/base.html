
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ruckus.base &#8212; ruckus 0.0.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>ruckus 0.0.5 documentation</span></a></h1>
        <h2 class="heading"><span>ruckus.base</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content" role="main">
        
        
  <h1>Source code for ruckus.base</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span> <span class="k">as</span> <span class="n">_reduce</span>

<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">BaseEstimator</span> <span class="k">as</span> <span class="n">_BaseEstimator</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">TransformerMixin</span> <span class="k">as</span> <span class="n">_TransformerMixin</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.validation</span> <span class="kn">import</span> <span class="n">check_is_fitted</span> <span class="k">as</span> <span class="n">_check_is_fitted</span>
<span class="kn">from</span> <span class="nn">sklearn.exceptions</span> <span class="kn">import</span> <span class="n">NotFittedError</span> <span class="k">as</span> <span class="n">_NotFittedError</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span> <span class="k">as</span> <span class="n">_Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span> <span class="k">as</span> <span class="n">_Ridge</span>
<span class="c1"># UTILITY RKHS&#39;s</span>

<div class="viewcode-block" id="RKHS"><a class="viewcode-back" href="../../api/base/RKHS.html#ruckus.base.RKHS">[docs]</a><span class="k">class</span> <span class="nc">RKHS</span><span class="p">(</span><span class="n">_TransformerMixin</span><span class="p">,</span><span class="n">_BaseEstimator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base instance of a Reproducing Kernel Hilbert Space [1]. An RKHS consists of a</span>
<span class="sd">    Hilbert space :math:`H`, a feature mapping :math:`\phi:X \rightarrow H` from the data</span>
<span class="sd">    space :math:`X` into :math:`H`, and a kernel :math:`k(x,y)` on :math:`X^2` defined by </span>
<span class="sd">    :math:`k(x,y) = \left&lt;\phi(x),\phi(y)\right&gt;_H`. This base RKHS sets :math:`H=X` by default, with</span>
<span class="sd">    :math:`\phi(x)=x` and :math:`k(x,y)=x^T y`.</span>

<span class="sd">    Certain functions :math:`f` may be represented in :math:`H` with a vector :math:`F`</span>
<span class="sd">    satisfying :math:`\left&lt;F,\phi(x)\right&gt;_H=f(x)` for all :math:`x \in X`. This representation can</span>
<span class="sd">    be discovered using ridge regression [2]. The set of valid functions depends </span>
<span class="sd">    on :math:`H` and :math:`k`. This base RKHS class can only represent *linear* functions. </span>

<span class="sd">    The :py:func:`fit` method will typically determine the dimensions and shapes of :math:`H`</span>
<span class="sd">    and :math:`X`, as well as any other necessary parameters for determining the</span>
<span class="sd">    feature mapping :math:`\phi`. The :py:func:`transform` method will implement the feature</span>
<span class="sd">    mapping :math:`\phi`. The :py:func:`kernel` method will evaluate the kernel :math:`k`. The</span>
<span class="sd">    :py:func:`fit_function` method will find the representation of a function :math:`f` given</span>
<span class="sd">    the vector :math:`y_i=f(x_i)` of its values on the predictor variables.</span>

<span class="sd">    RKHS instances can be combined with one another via composition, direct sum</span>
<span class="sd">    and tensor product. These produce compound RKHS classes, :py:class:`CompositeRKHS`,</span>
<span class="sd">    :py:class:`DirectSumRKHS`, and :py:class:`ProductRKHS`. These combinations can be instantiated</span>
<span class="sd">    with the corresponding class, or generated from arbitrary RKHS instances</span>
<span class="sd">    using the operations ``@`` for composition, ``+`` for direct sum, and ``*`` for</span>
<span class="sd">    tensor product. See the corresponding classes for further details.</span>

<span class="sd">    1. `Aronszajn, N. &quot;Theory of reproducing kernels.&quot; Trans. Amer. Math. Soc. 68 (1950), 337-404. &lt;https://www.ams.org/journals/tran/1950-068-03/S0002-9947-1950-0051437-7/&gt;`_</span>
<span class="sd">    2. Murphy, K. P. &quot;Machine Learning: A Probabilistic Perspective&quot;, The MIT Press. chapter 14.4.3, pp. 492-493</span>
<span class="sd">    </span>
<span class="sd">    ==========</span>
<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    :param take: Default = ``None``.</span>
<span class="sd">        Specifies which values to take from the datapoint for transformation.</span>
<span class="sd">        If ``None``, the entire datapoint will be taken in its original shape.</span>
<span class="sd">        If ``bool`` array, acts as a mask setting values marked ``False`` to ``0`` and leaving values marked True unchanged.</span>
<span class="sd">        If ``int`` array, the integers specify the indices (along the first feature dimension) which are to be taken, in the order/shape of the desired input.</span>
<span class="sd">        If ``tuple`` of ``int`` arrays, allows for drawing indices across multiple dimensions, similar to passing a ``tuple`` to a ``numpy`` array.</span>
<span class="sd">    :type take: :py:class:`numpy.ndarray` of ``dtype int`` or ``bool``, or ``tuple`` of :py:class:`numpy.ndarray` instances of type ``int``, or ``None``</span>
<span class="sd">    :param filter: Default = ``None``.</span>
<span class="sd">        Specifies a linear preprocessing of the data. Applied after take.</span>
<span class="sd">        If ``None``, no changes are made to the input data.</span>
<span class="sd">        If the same shape as the input datapoints, ``filter`` and the datapoint are multiplied elementwise. </span>
<span class="sd">        If ``filter`` has a larger dimension than the datapoint, then its first dimensions will be contracted with the datapoint via :py:func:`numpy.tensordot`. The final shape is determined by the remaining dimensions of filter.</span>
<span class="sd">    :type filter: :py:class:`numpy.ndarray` of ``dtype float`` or ``None``</span>
<span class="sd">    :param copy_X: Default = ``True``.</span>
<span class="sd">        If ``True``, input ``X`` is copied and stored by the model in the ``X_fit_`` attribute. If no further changes will be done to ``X``, setting ``copy_X=False`` saves memory by storing a reference.</span>
<span class="sd">    :type copy_X: ``bool``</span>

<span class="sd">    ==========</span>
<span class="sd">    Attributes</span>
<span class="sd">    ==========</span>
<span class="sd">    :param shape_in\_: The required shape of the input datapoints, aka the shape of the domain space :math:`X`.</span>
<span class="sd">    :type shape_in\_: ``tuple``</span>
<span class="sd">    :param shape_out\_: The final shape of the transformed datapoints, aka the shape of the Hilbert space :math:`H`.</span>
<span class="sd">    :type shape_out\_: ``tuple``</span>
<span class="sd">    :param X_fit\_: The data which was used to fit the model.</span>
<span class="sd">    :type X_fit\_: :py:class:`numpy.ndarray` of shape `(n_samples,)+self.shape_in_`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="n">take</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">copy_X</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">take</span> <span class="o">=</span> <span class="n">take</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">filter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span> <span class="o">=</span> <span class="n">copy_X</span>
        <span class="k">return</span> <span class="kc">None</span>
    
<div class="viewcode-block" id="RKHS.fit"><a class="viewcode-back" href="../../api/base/RKHS.html#ruckus.base.RKHS.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model from data in ``X``.</span>

<span class="sd">        :param X: Training vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. Must be consistent with preprocessing instructions in ``self.take`` and ``self.filter``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``</span>

<span class="sd">        :param y: Not used, present for API consistency by convention.</span>
<span class="sd">        :type y: Ignored            </span>

<span class="sd">        :returns: The instance itself</span>
<span class="sd">        :rtype: :py:class:`RKHS`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">,</span><span class="n">allow_nd</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_out_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="RKHS.transform"><a class="viewcode-back" href="../../api/base/RKHS.html#ruckus.base.RKHS.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform ``X``.</span>

<span class="sd">        :param X: Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :returns: The transformed data</span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples,)+self.shape_out_``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">,</span><span class="n">allow_nd</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_in_</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_filter</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_out_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The input shape of the data, </span><span class="si">%s</span><span class="s1">, does not match the required input type, </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_in_</span><span class="p">)))</span></div>

<div class="viewcode-block" id="RKHS.fit_transform"><a class="viewcode-back" href="../../api/base/RKHS.html#ruckus.base.RKHS.fit_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model from data in ``X`` and transform ``X``.</span>

<span class="sd">        :param X: Training vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. Must be consistent with preprocessing instructions in ``self.take`` and ``self.filter``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``        </span>

<span class="sd">        :returns: The transformed data</span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples,)+self.shape_out_``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">X_transformed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">X_transformed</span></div>

<div class="viewcode-block" id="RKHS.kernel"><a class="viewcode-back" href="../../api/base/RKHS.html#ruckus.base.RKHS.kernel">[docs]</a>    <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates the kernel on ``X`` and ``Y`` (or ``X`` and ``X``).</span>

<span class="sd">        :param X: Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :param Y: Default = ``None``.</span>
<span class="sd">            Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``. If ``None``, ``X`` is used.</span>
<span class="sd">        :type Y: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :returns: The matrix ``K[i,j] = k(X[i],Y[j])`` </span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples_1,n_samples_2)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">,</span><span class="n">allow_nd</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">,</span><span class="n">allow_nd</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">@</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>

<div class="viewcode-block" id="RKHS.fit_function"><a class="viewcode-back" href="../../api/base/RKHS.html#ruckus.base.RKHS.fit_function">[docs]</a>    <span class="k">def</span> <span class="nf">fit_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">regressor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a function using its values on the predictor data and a regressor.</span>

<span class="sd">        :param y: Target vector, where ``n_samples`` is the number of samples and ``n_targets`` is the number of target functions.</span>
<span class="sd">        :type y: :py:class:`numpy.ndarray` of shape ``(n_samples, n_targets)``   </span>

<span class="sd">        :param X: Default = ``None``.</span>
<span class="sd">            Training vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``. If ``None``, ``self.X_fit_`` is used.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :param regressor: The regressor object to use to fit the function. If ``None``, a :py:class:`sklearn.linear_model.Ridge` instance is used with ``fit_intercept=False`` and ``alpha`` specified below.</span>
<span class="sd">        :type regressor: :py:class:`sklearn.base.BaseEstimator`</span>

<span class="sd">        :param alpha: The ridge parameter used in the default Ridge regressor.</span>
<span class="sd">        :param type: float</span>

<span class="sd">        :returns: ``regressor``, fitted to provide the function representation.</span>
<span class="sd">        :rtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">,</span><span class="n">allow_nd</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">regressor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">regressor</span> <span class="o">=</span> <span class="n">_Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span><span class="n">fit_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">X_reps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">,</span><span class="n">allow_nd</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">regressor</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_reps</span><span class="p">,</span><span class="n">y</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs the :py:class:`CompositeRKHS` from ``self`` and ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompositeRKHS</span><span class="p">([</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">],</span><span class="n">copy_X</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">copy_X</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs the :py:class:`ProductRKHS` from ``self`` and ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ProductRKHS</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">],</span><span class="n">copy_X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">copy_X</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs the :py:class:`DirectSumRKHS` from ``self`` and ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DirectSumRKHS</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">],</span><span class="n">copy_X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">copy_X</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies ``self.take`` and ``self.filter`` to the input data as a preprocessing step.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_take</span><span class="p">(</span><span class="n">X</span><span class="p">,)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="p">)),</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">))))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;First </span><span class="si">%d</span><span class="s1"> axes of filter must have same shape as the last </span><span class="si">%d</span><span class="s1"> axes of apply_take(X,take).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Dimension of filter must be at least </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
            
    <span class="k">def</span> <span class="nf">_apply_take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies ``take`` to the input data as a preprocessing step.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">X</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="nb">bool</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="n">_np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int64&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">X</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;take is not of the right form (must either be a boolean mask, an array of indices, or a tuple of integer arrays&#39;</span><span class="p">)</span></div>

<span class="c1"># Compound RKHS&#39;s</span>
<div class="viewcode-block" id="CompositeRKHS"><a class="viewcode-back" href="../../api/base/CompositeRKHS.html#ruckus.base.CompositeRKHS">[docs]</a><span class="k">class</span> <span class="nc">CompositeRKHS</span><span class="p">(</span><span class="n">RKHS</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a sequence of RKHS&#39;s with Hilbert spaces :math:`H_1`, ..., :math:`H_n` and feature</span>
<span class="sd">    maps :math:`\phi_1`, ..., :math:`\phi_n`, their composition lives in the final Hilbert</span>
<span class="sd">    space :math:`H_n` but has feature map :math:`\phi_n \circ \dots \circ \phi_1` [1].</span>
<span class="sd">    Correspondingly, a ``CompositeRKHS`` class has the ``shape_out_`` of its final</span>
<span class="sd">    component, the ``shape_in_`` of its first component, and :py:func:`transform` is applied to the data</span>
<span class="sd">    by implementing ``transform`` sequentially for each of the component spaces.</span>
<span class="sd">    This is useful for building pipelines and deep kernels.</span>

<span class="sd">    1. `Cho, Y., Lawrence, S. &quot;Kernel Methods for Deep Learning.&quot; Advances in Neural Information Processing Systems 22 (NIPS 2009) &lt;https://papers.nips.cc/paper/2009/hash/5751ec3e9a4feab575962e78e006250d-Abstract.html/&gt;`_</span>

<span class="sd">    ==========</span>
<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    :param components:  The component :py:class:`RKHS` objects, listed from the first to be applied to the last.</span>
<span class="sd">    :type components: list of :py:class:`RKHS` objects</span>
<span class="sd">               </span>
<span class="sd">    :param copy_X: Default = ``True``.</span>
<span class="sd">        If ``True``, input ``X`` is copied and stored by the model in the ``X_fit_`` attribute. If no further changes will be done to ``X``, setting ``copy_X=False`` saves memory by storing a reference.</span>
<span class="sd">    :type copy_X: ``bool``</span>

<span class="sd">    ==========</span>
<span class="sd">    Attributes</span>
<span class="sd">    ==========</span>
<span class="sd">    :param shape_in\_: The required shape of the input datapoints, aka the shape of the domain space :math:`X`.</span>
<span class="sd">    :type shape_in\_: ``tuple``</span>
<span class="sd">    :param shape_out\_: The final shape of the transformed datapoints, aka the shape of the Hilbert space :math:`H`.</span>
<span class="sd">    :type shape_out\_: ``tuple``</span>
<span class="sd">    :param X_fit\_: The data which was used to fit the model.</span>
<span class="sd">    :type X_fit\_: :py:class:`numpy.ndarray` of shape `(n_samples,)+self.shape_in_`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">components</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">copy_X</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span> <span class="o">=</span> <span class="n">copy_X</span>

<div class="viewcode-block" id="CompositeRKHS.fit_transform"><a class="viewcode-back" href="../../api/base/CompositeRKHS.html#ruckus.base.CompositeRKHS.fit_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model from data in ``X`` and transform ``X``.</span>

<span class="sd">        :param X: Training vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. Must be consistent with preprocessing instructions in `self.components[0].take` and `self.components[0].filter`.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``        </span>

<span class="sd">        :returns: The transformed data</span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples,)+self.shape_out_``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">current_X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span>
        <span class="k">for</span> <span class="n">rkhs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">new_X</span> <span class="o">=</span> <span class="n">rkhs</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">current_X</span><span class="p">)</span>
            <span class="n">current_X</span> <span class="o">=</span> <span class="n">new_X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">current_X</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shape_out_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape_out_</span>

        <span class="k">return</span> <span class="n">current_X</span></div>

<div class="viewcode-block" id="CompositeRKHS.fit"><a class="viewcode-back" href="../../api/base/CompositeRKHS.html#ruckus.base.CompositeRKHS.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model from data in ``X`.</span>

<span class="sd">        :param X: Training vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. Must be consistent with preprocessing instructions in `self.components[0].take` and `self.components[0].filter`.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``        </span>

<span class="sd">        :returns: The instance itself</span>
<span class="sd">        :rtype: :py:class:`RKHS`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CompositeRKHS.transform"><a class="viewcode-back" href="../../api/base/CompositeRKHS.html#ruckus.base.CompositeRKHS.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform ``X``.</span>

<span class="sd">        :param X: Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :returns: The transformed data</span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples,)+self.shape_out_``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">current_X</span> <span class="o">=</span> <span class="n">X</span>

        <span class="k">for</span> <span class="n">rkhs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="n">new_X</span> <span class="o">=</span> <span class="n">rkhs</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">current_X</span><span class="p">)</span>
            <span class="n">current_X</span> <span class="o">=</span> <span class="n">new_X</span>

        <span class="k">return</span> <span class="n">current_X</span></div>

<div class="viewcode-block" id="CompositeRKHS.kernel"><a class="viewcode-back" href="../../api/base/CompositeRKHS.html#ruckus.base.CompositeRKHS.kernel">[docs]</a>    <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates the kernel on ``X`` and ``Y`` (or ``X`` and ``X``) by iterating over component</span>
<span class="sd">        embeddings. As such, ``CompositeRKHS`` kernels can only be evaluated after fitting to data.</span>

<span class="sd">        :param X: Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :param Y: Default = ``None``.</span>
<span class="sd">            Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``. If ``None``, ``X`` is used.</span>
<span class="sd">        :type Y: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :returns: The matrix ``K[i,j] = k(X[i],Y[j])`` </span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples_1,n_samples_2)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">:</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">current_X</span> <span class="o">=</span> <span class="n">X</span>

            <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">current_Y</span> <span class="o">=</span> <span class="n">current_X</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">:</span>
                    <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">current_Y</span> <span class="o">=</span> <span class="n">Y</span>

            <span class="k">for</span> <span class="n">rkhs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">current_X</span> <span class="o">=</span> <span class="n">rkhs</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">current_X</span><span class="p">)</span>
                <span class="n">current_Y</span> <span class="o">=</span> <span class="n">rkhs</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">current_Y</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">current_X</span><span class="p">,</span><span class="n">current_Y</span><span class="p">)</span>

        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_NotFittedError</span><span class="p">(</span><span class="s2">&quot;Composite RKHS&#39;s must be fitted before their kernels can be evaluated.&quot;</span><span class="p">)</span></div>
        
    <span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs the ``CompositeRKHS`` from ``self` and `other``. Flattens the component list to avoid unnecessary recursion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">CompositeRKHS</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CompositeRKHS</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">components</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span><span class="n">copy_X</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">copy_X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CompositeRKHS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">other</span><span class="p">),</span><span class="n">copy_X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductRKHS"><a class="viewcode-back" href="../../api/base/ProductRKHS.html#ruckus.base.ProductRKHS">[docs]</a><span class="k">class</span> <span class="nc">ProductRKHS</span><span class="p">(</span><span class="n">RKHS</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a sequence of RKHS&#39;s with Hilbert spaces :math:`H_1`, ..., :math:`H_n` and feature</span>
<span class="sd">    maps :math:`\phi_1`, ..., :math:`\phi_n`, their composition lives in the tensor product Hilbert</span>
<span class="sd">    space :math:`H_1\otimes \dots \otimes H_n` and has feature map </span>
<span class="sd">    :math:`\phi_1 \otimes \dots \otimes \phi_n` [1].</span>
<span class="sd">    Correspondingly, the ``shape_out_`` of a ``ProductRKHS`` instance is the</span>
<span class="sd">    tuple-sum of the ``shape_out_`` tuples of its factors, while all its factors share</span>
<span class="sd">    the same ``shape_in_``.</span>

<span class="sd">    Product RKHS&#39;s are particularly useful for working with kernel embeddings of</span>
<span class="sd">    distributions and their conditional probabilities [2]. A ``ProductRKHS`` can</span>
<span class="sd">    be reduced to its marginal along a set of factors using the :py:func:`marginal`</span>
<span class="sd">    method, and can be reduced into a marginal space paired with a</span>
<span class="sd">    ridge-regressed conditional map using the :py:func:`conditional` method.</span>

<span class="sd">    1. `Aronszajn, N. &quot;Theory of reproducing kernels.&quot; Trans. Amer. Math. Soc. 68 (1950), 337-404. &lt;https://www.ams.org/journals/tran/1950-068-03/S0002-9947-1950-0051437-7/&gt;`_</span>
<span class="sd">    2. `Muandet, K., Fukuzimu, K., Sriperumbudur, B., Schölkopf, B. &quot;Kernel Mean Embedding of Distributions: A Review and Beyond.&quot; Foundations and Trends in Machine Learning: Vol. 10: No. 1-2, pp 1-141 (2017) &lt;https://arxiv.org/abs/1605.09522/&gt;`_</span>

<span class="sd">    ==========</span>
<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    :param factors:  The factor :py:class:`RKHS` objects, listed in the order that their dimensions will appear in indexing.</span>
<span class="sd">    :type factors: list of :py:class:`RKHS` objects</span>
<span class="sd">               </span>
<span class="sd">    :param copy_X: Default = ``True``.</span>
<span class="sd">        If ``True``, input ``X`` is copied and stored by the model in the ``X_fit_`` attribute. If no further changes will be done to ``X``, setting ``copy_X=False`` saves memory by storing a reference.</span>
<span class="sd">    :type copy_X: ``bool``</span>

<span class="sd">    ==========</span>
<span class="sd">    Attributes</span>
<span class="sd">    ==========</span>
<span class="sd">    :param shape_in\_: The required shape of the input datapoints, aka the shape of the domain space :math:`X`.</span>
<span class="sd">    :type shape_in\_: ``tuple``</span>
<span class="sd">    :param shape_out\_: The final shape of the transformed datapoints, aka the shape of the Hilbert space :math:`H`.</span>
<span class="sd">    :type shape_out\_: ``tuple``</span>
<span class="sd">    :param X_fit\_: The data which was used to fit the model.</span>
<span class="sd">    :type X_fit\_: :py:class:`numpy.ndarray` of shape `(n_samples,)+self.shape_in_`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">factors</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">copy_X</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">=</span> <span class="n">factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span> <span class="o">=</span> <span class="n">copy_X</span>

<div class="viewcode-block" id="ProductRKHS.fit"><a class="viewcode-back" href="../../api/base/ProductRKHS.html#ruckus.base.ProductRKHS.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model from data in ``X``.</span>

<span class="sd">        :param X: Training vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. Must be consistent with preprocessing instructions in `fac.take` and `fac.filter` for each `fac` in `self.factors`.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``        </span>

<span class="sd">        :returns: The instance itself</span>
<span class="sd">        :rtype: :py:class:`RKHS`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_out_</span> <span class="o">=</span> <span class="n">_reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">shape_out_</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">],</span> <span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span></div>
    
<div class="viewcode-block" id="ProductRKHS.transform"><a class="viewcode-back" href="../../api/base/ProductRKHS.html#ruckus.base.ProductRKHS.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform ``X``.</span>

<span class="sd">        :param X: Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :returns: The transformed data</span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples,)+self.shape_out_``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">Ys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">)):</span>
            <span class="n">Ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        
        <span class="c1"># Performs a vectorized tensor product of the feature dimensions</span>
        <span class="n">tensor_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">:</span> <span class="n">A</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">B</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">_reduce</span><span class="p">(</span><span class="n">tensor_func</span><span class="p">,</span><span class="n">Ys</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">Ys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>
    
<div class="viewcode-block" id="ProductRKHS.kernel"><a class="viewcode-back" href="../../api/base/ProductRKHS.html#ruckus.base.ProductRKHS.kernel">[docs]</a>    <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates the kernel on ``X`` and ``Y`` (or ``X`` and ``X``) by multiplying the kernels of the factors.</span>

<span class="sd">        :param X: Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :param Y: Default = ``None``.</span>
<span class="sd">            Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``. If ``None``, ``X`` is used.</span>
<span class="sd">        :type Y: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :returns: The matrix ``K[i,j] = k(X[i],Y[j])`` </span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples_1,n_samples_2)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">:</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">Ks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">)):</span>
            <span class="n">Ks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">Ks</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductRKHS.marginal"><a class="viewcode-back" href="../../api/base/ProductRKHS.html#ruckus.base.ProductRKHS.marginal">[docs]</a>    <span class="k">def</span> <span class="nf">marginal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">var_inds</span><span class="p">,</span><span class="n">copy_X</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a ``ProductRKHS`` from only the factors specified by ``var_inds``.</span>
<span class="sd">        Only to be used if ``ProductRKHS`` is already fit, and you&#39;d rather not</span>
<span class="sd">        fit again.</span>

<span class="sd">        :param var_inds: List of indices of the factors in ``self.factors`` from which to the marginal ``ProductRKHS``.</span>
<span class="sd">        :type var_inds: ``array`` -like of ``int``</span>
<span class="sd">        :param copy_X: Default = ``True``.</span>
<span class="sd">            If ``True``, input ``self.X_fit_`` is copied and stored as the new model&#39;s ``X_fit_`` attribute. If no further changes will be done to ``X``, setting ``copy_X=False`` saves memory by storing a reference.</span>
<span class="sd">        :type copy_X: ``bool``</span>

<span class="sd">        :returns: The marginal ``ProductRKHS`` of the ``var_inds``.</span>
<span class="sd">        :rtype: ``ProductRKHS``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_rkhs</span> <span class="o">=</span> <span class="n">ProductRKHS</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="n">var_inds</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">copy_X</span><span class="p">:</span>
            <span class="n">new_rkhs</span><span class="o">.</span><span class="n">X_fit_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_rkhs</span><span class="o">.</span><span class="n">X_fit_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span>
        <span class="n">new_rkhs</span><span class="o">.</span><span class="n">shape_in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">new_rkhs</span><span class="o">.</span><span class="n">shape_out_</span> <span class="o">=</span> <span class="n">_reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">shape_out_</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_rkhs</span><span class="o">.</span><span class="n">factors</span><span class="p">],</span> <span class="p">())</span>
        <span class="k">return</span> <span class="n">new_rkhs</span></div>

<div class="viewcode-block" id="ProductRKHS.conditional"><a class="viewcode-back" href="../../api/base/ProductRKHS.html#ruckus.base.ProductRKHS.conditional">[docs]</a>    <span class="k">def</span> <span class="nf">conditional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">predictor_inds</span><span class="p">,</span><span class="n">response_inds</span><span class="p">,</span><span class="n">regressor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a pair of outputs, the first being a :py:class:`sklearn.pipelines.Pipeline` </span>
<span class="sd">        consisting of the marginal RKHS of ``predictor_inds`` and a regressor which represents </span>
<span class="sd">        the conditional distribution embedding, and the second being the marginal RKHS </span>
<span class="sd">        of ``response_inds``.</span>

<span class="sd">        For two systems :math:`X` and :math:`Y`, embedded in Hilbert spaces </span>
<span class="sd">        :math:`H_1` and :math:`H_2` respectively, the conditional distribution </span>
<span class="sd">        embedding is a linear map :math:`C_{Y|X}:H_1\\rightarrow H_2` such that </span>
<span class="sd">        :math:`C_{Y|X}\phi_1(x)` gives the kernel embedding of the distribution</span>
<span class="sd">        of :math:`Y` conditioned on :math:`X=x`. This is typically determined</span>
<span class="sd">        by using a ridge regression, though we allow the user to pass a custom </span>
<span class="sd">        regressor for model selection purposes. See [1] for details.</span>

<span class="sd">        1. `Muandet, K., Fukuzimu, K., Sriperumbudur, B., Schölkopf, B. &quot;Kernel Mean Embedding of Distributions: A Review and Beyond.&quot; Foundations and Trends in Machine Learning: Vol. 10: No. 1-2, pp 1-141 (2017) &lt;https://arxiv.org/abs/1605.09522/&gt;`_</span>

<span class="sd">        :param predictor_inds: List of indices of the factors in ``self.factors`` on which the ``response_inds`` will be conditioned.</span>
<span class="sd">        :type predictor_inds: ``array`` -like of ``int``</span>
<span class="sd">        :param response_inds: List of indices of the factors in ``self.factors`` which are to be conditioned on the ``predictor_inds``.</span>
<span class="sd">        :type predictor_inds: ``array`` -like of ``int``</span>
<span class="sd">        :param regressor: The regressor object to use to fit the conditional embedding. If ``None``, a :py:class:`sklearn.linear_model.Ridge` instance is used with ``fit_intercept=False`` and ``alpha`` specified below.</span>
<span class="sd">        :type regressor: :py:class:`sklearn.base.BaseEstimator`</span>
<span class="sd">        :param alpha: The ridge parameter used in the default Ridge regressor.</span>
<span class="sd">        :type alpha: float</span>

<span class="sd">        :returns: (``pipe``,``response``), where ``pipe`` is a pipeline consisting of the marginal of ``predictor_inds`` and the fitted ``regressor``, and ``response`` is the marginal of ``response_inds``.</span>
<span class="sd">        :rtype: (:py:class:`sklearn.pipelines.Pipeline`, ``ProductRKHS``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">regressor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">regressor</span> <span class="o">=</span> <span class="n">_Ridge</span><span class="p">(</span><span class="n">fit_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>

        <span class="n">rkhs_predictor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginal</span><span class="p">(</span><span class="n">predictor_inds</span><span class="p">)</span>
        <span class="n">rkhs_response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginal</span><span class="p">(</span><span class="n">response_inds</span><span class="p">)</span>

        <span class="n">X_in</span> <span class="o">=</span> <span class="n">rkhs_predictor</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">rkhs_predictor</span><span class="o">.</span><span class="n">X_fit_</span><span class="p">)</span>
        <span class="n">y_in</span> <span class="o">=</span> <span class="n">rkhs_response</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">rkhs_response</span><span class="o">.</span><span class="n">X_fit_</span><span class="p">)</span>
        <span class="n">regressor</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_in</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">X_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">_np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">X_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]),</span>
                      <span class="n">y_in</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">y_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">_np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">y_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]))</span>

        <span class="n">pipe</span> <span class="o">=</span> <span class="n">_Pipeline</span><span class="p">([(</span><span class="s1">&#39;embedding&#39;</span><span class="p">,</span><span class="n">rkhs_predictor</span><span class="p">),(</span><span class="s1">&#39;regressor&#39;</span><span class="p">,</span><span class="n">regressor</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">pipe</span><span class="p">,</span><span class="n">rkhs_response</span></div>
    
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs the ``ProductRKHS`` from ``self` and `other``. Flattens the factor list to avoid unnecessary recursion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ProductRKHS</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ProductRKHS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">+</span><span class="n">other</span><span class="o">.</span><span class="n">factors</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="o">+</span><span class="n">other</span><span class="o">.</span><span class="n">filters</span><span class="p">,</span><span class="n">copy_X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">copy_X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ProductRKHS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">[</span><span class="n">other</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">append</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span><span class="n">copy_X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">)</span></div>

<div class="viewcode-block" id="DirectSumRKHS"><a class="viewcode-back" href="../../api/base/DirectSumRKHS.html#ruckus.base.DirectSumRKHS">[docs]</a><span class="k">class</span> <span class="nc">DirectSumRKHS</span><span class="p">(</span><span class="n">RKHS</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a sequence of RKHS&#39;s with Hilbert spaces :math:`H_1`, ..., :math:`H_n` and feature</span>
<span class="sd">    maps :math:`\phi_1`, ..., :math:`\phi_n`, their direct sum lives in the tensor product Hilbert</span>
<span class="sd">    space :math:`H_1\oplus \dots \oplus H_n` and has feature map of stacked vectors</span>
<span class="sd">    :math:`[\phi_1^T,\ \dots,\ \phi_n^T]^T` [1].</span>
<span class="sd">    Correspondingly, the ``shape_out_`` of a ``DirectRKHS`` instance is determined the the same manner</span>
<span class="sd">    as when using :py:func:`numpy.concatenate` on the specified axis, while all its subspaces share</span>
<span class="sd">    the same ``shape_in_``.</span>

<span class="sd">    1. `Aronszajn, N. &quot;Theory of reproducing kernels.&quot; Trans. Amer. Math. Soc. 68 (1950), 337-404. &lt;https://www.ams.org/journals/tran/1950-068-03/S0002-9947-1950-0051437-7/&gt;`_</span>

<span class="sd">    ==========</span>
<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    :param subspaces:  The subspace :py:class:`RKHS` objects, listed in the order that their indices will appear along the first axis.</span>
<span class="sd">    :type subspaces: list of :py:class:`RKHS` objects</span>

<span class="sd">    :param axis:  The axis along which the data will be concatenated. Data dimension must match on all other axes.</span>
<span class="sd">    :type axis: int</span>
<span class="sd">               </span>
<span class="sd">    :param copy_X: Default = ``True``.</span>
<span class="sd">        If ``True``, input ``X`` is copied and stored by the model in the ``X_fit_`` attribute. If no further changes will be done to ``X``, setting ``copy_X=False`` saves memory by storing a reference.</span>
<span class="sd">    :type copy_X: ``bool``</span>

<span class="sd">    ==========</span>
<span class="sd">    Attributes</span>
<span class="sd">    ==========</span>
<span class="sd">    :param shape_in\_: The required shape of the input datapoints, aka the shape of the domain space :math:`X`.</span>
<span class="sd">    :type shape_in\_: ``tuple``</span>
<span class="sd">    :param shape_out\_: The final shape of the transformed datapoints, aka the shape of the Hilbert space :math:`H`.</span>
<span class="sd">    :type shape_out\_: ``tuple``</span>
<span class="sd">    :param X_fit\_: The data which was used to fit the model.</span>
<span class="sd">    :type X_fit\_: :py:class:`numpy.ndarray` of shape `(n_samples,)+self.shape_in_`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">subspaces</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">copy_X</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span> <span class="o">=</span> <span class="n">subspaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span> <span class="o">=</span> <span class="n">copy_X</span>

<div class="viewcode-block" id="DirectSumRKHS.fit"><a class="viewcode-back" href="../../api/base/DirectSumRKHS.html#ruckus.base.DirectSumRKHS.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model from data in ``X``.</span>

<span class="sd">        :param X: Training vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. Must be consistent with preprocessing instructions in `sub.take` and `sub.filter` for each `sub` in `self.subspaces`.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``        </span>

<span class="sd">        :returns: The instance itself</span>
<span class="sd">        :rtype: :py:class:`RKHS`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_fit_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">shapes_out</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape_out_</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span><span class="p">])</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">shapes_out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_mask</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shapes_out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">axis_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">shapes_out</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="n">axes</span><span class="p">]</span><span class="o">==</span><span class="n">shapes_out</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">axes</span><span class="p">]):</span>
            <span class="n">shapesum</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">sh1</span><span class="p">,</span><span class="n">sh2</span><span class="p">:</span><span class="n">sh1</span><span class="o">+</span><span class="n">axis_mask</span><span class="o">*</span><span class="n">sh2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape_out_</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_reduce</span><span class="p">(</span><span class="n">shapesum</span><span class="p">,</span><span class="n">shapes_out</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">shapes_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Subspaces have incompatible shapes for direct sum&#39;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="bp">self</span></div>
    
<div class="viewcode-block" id="DirectSumRKHS.transform"><a class="viewcode-back" href="../../api/base/DirectSumRKHS.html#ruckus.base.DirectSumRKHS.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform ``X``.</span>

<span class="sd">        :param X: Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :returns: The transformed data</span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples,)+self.shape_out_``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">Ys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">Ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">Ys</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="DirectSumRKHS.kernel"><a class="viewcode-back" href="../../api/base/DirectSumRKHS.html#ruckus.base.DirectSumRKHS.kernel">[docs]</a>    <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates the kernel on ``X`` and ``Y`` (or ``X`` and ``X``) by summing the kernels of the factors.</span>

<span class="sd">        :param X: Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``.</span>
<span class="sd">        :type X: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :param Y: Default = ``None``.</span>
<span class="sd">            Data vector, where ``n_samples`` is the number of samples and ``(n_features_1,...,n_features_d)`` is the shape of the input data. These must match ``self.shape_in_``. If ``None``, ``X`` is used.</span>
<span class="sd">        :type Y: :py:class:`numpy.ndarray` of shape ``(n_samples, n_features_1,...,n_features_d)``   </span>

<span class="sd">        :returns: The matrix ``K[i,j] = k(X[i],Y[j])`` </span>
<span class="sd">        :rtype: :py:class:`numpy.ndarray` of shape ``(n_samples_1,n_samples_2)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">:</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">Ks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span><span class="p">)):</span>
            <span class="n">Ks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Ks</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>
    
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs the ``DirectSumRKHS`` from ``self` and `other``. Flattens the subspace list to avoid unnecessary recursion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">DirectSumRKHS</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DirectSumRKHS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span><span class="o">+</span><span class="n">other</span><span class="o">.</span><span class="n">subspaces</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="o">+</span><span class="n">other</span><span class="o">.</span><span class="n">filters</span><span class="p">,</span><span class="n">copy_X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">copy_X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DirectSumRKHS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subspaces</span><span class="o">.</span><span class="n">append</span><span class="p">[</span><span class="n">other</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">append</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span><span class="n">copy_X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X</span><span class="p">)</span></div>
</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Samuel Loomis.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>